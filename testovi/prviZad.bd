1.) 12. 11. 2019
U bazi podataka trgovinskiLanac kreirane su relacije pomocu prikazanih naredbi

    CREATE TABLE trgovina  (         CREATE TABLE proizvodUTrgovini (
      sifTrgovina   INTEGER             sifTrgovina   INT
      nazivTrgovina CHAR NOT NULL       sifProizvod   INT
      adresaTrgovina                    datum         DATE
    );                                  cijena        DECIMAL
                                          
    CREATE TABLE proizvod (          CREATE TABLE dvnevnik (
      sifProizvod     INTEGER           sifTrgovina INT
      nazivProizvod   CHAR              sifProizvod INT
    );                                  datum
                                        cijena 
                                     );

Napisati po jednu SQL naredbu za svaki sljedeci zadatak.

Upiti moraju biti neovisni o datumu izvodjenja
Nece se priznavati rjesenja u kojima se nepotrebno koriste podupiti.

    a) Ispisati broj razlicitih proizvoda u trgovinama ciji naziv pocinje slovima 
    od M do P, a zavrsava suglasnikom i kojima su cijene postavljene prije vise 
    od pola godine. (2b)

      SELECT COUNt (DISTINCT put.sifProizvod) FROM proizvodUTrgovini put 
      INNER JOIN trgovina t 
      ON put.sifTrgovina = t.sifTrgovina 
      WHERE nazivTrgovina RLIKE '^[M-P]' AND nazivTrgovina RLIKE '[^aeiou]$' 
      AND datum < DATE_SUB(curdate(), INTERVAL 6 MONTH);

    b) Za svaku trgovinu ispisati naziv trgovine, adresu i naziv trenutno 
    najskupljeg proizvoda u toj trgovini (pretpostaviti da postoji samo jedan
    takav proizvod) (2b)

      SELECT nazivTrgovina, adresaTrgovina, nazivProizvod FROM trgovina 
      INNER JOIN proizvodUTrgovini pot ON pot.sifTrgovina = trgovina.sifTrgovina 
      INNER JOIN proizvod ON proizvod.sifProizvod = pot.sifProizvod 
      WHERE cijena = (SELECT MAX(put2.cijena) FROM proizvodUTrgovini put2 
      WHERE t.sifTrgovina = put2.sifTrgovina);

    c) Ispisati naziv trgovine i naziv proizvoda u toj trgovini koji niti jednom 
    nisu promijenili cijenu u nekakvoj drugoj trgovini. (2b)

      SELECT nazivTrgovina, nazivProizvod FROM trgovina INNER JOIN proizvodUTrgovini 
      ON trgovina.sifTrgovina = proizvodUTrgovini.sifTrgovina 
      INNER JOIN proizvod ON proizvod.sifProizvod = proizvodUTrgovini.sifProizvod 
      WHERE NOT EXISTS (
          SELECT * 
          FROM dnevnik d 
          WHERE d.sifProizvod = put.sifProizvod
          AND d.sifTrgovina <> put.sifTrgovina


1.) 13.11.2018 
U bazi podataka kreirane su tablice:

LUKA                                      PLOVIDBA 
  sifLuka     INTEGER   (sifra luke)        regBrBrod       CHAR    (registarski broj broda)
  nazLuka     CHAR      (naziv luke)        datPolaska      DATE    (datum polaska broda)
                                            sifLukaOd       INT     (sifra luke iz koje brod polazi (isplovava))
                                            sifLukaDo       INT     (sifra luke u koju brod dolazi (uplovaljava))
                                            datDolaska      DATE    (datum dolaska broda u luku u koju plovi)
                                            ukUkrcTezina    INT     (ukupna na broj ukrcana tezina tereta na toj plovidbi)
BROD
  regBrBrod       CHAR    (registarski broj broda)
  imeBrod         CHAR    (ime broda)
  nosivost        INT     (najveca ukupna tezina koju brod moze ukcrati u t)
  sifMaticLuka    INT     (sifra maticne luke broda (luka u kojoj je registrovan))


Napisati po jednu SQL naredbu za svaki sljedeci zadatak. Upiti moraju biti neovisni o datumu izvodnjenja.
Ne prihvataju se rjesenja gdje se nepotrebno koriste podupiti

  a) Ispisati registarske brojeve i imena brodova koji su plovidbu zapoceli u toku posljednjih 10 dana 
     i u odredisnu luku nece uploviti barem jos 3 dana (2b)

     SELECT b.regBrBrod, b.imeBrod FROM brod b INNER JOIN plovidba p ON b.rebBrBrod = p.regBrBrod 
     WHERE datPolaska >= DATE_SUB(curdate(),INTERVAL 10 DAY) 
     AND datDolaska >= date_adD(curDaTe(), INTERVAL 3 DAY);

  b) Ispistai registarske brojeve i imena brodova koji su iz luke Rijeka u luku New York barem jednom
     prevozili teret ukupne ukrcane tezine vece od 200t. Svaki brod se u listi smije pojviti 
     najvise jednom. (2b)

     SELECT DISTINCT b.regBrBrod, b.imeBrod FROM brod b INNER JOIN plovidba p ON b.regBrBrod = p.regBrBrod 
     INNER JOIN luka lukaOd ON lukaOd.sifLuka = p.sifLukaOd INNER JOIN luka lukaDo ON lukaDo.sifLuka = p.sifLukaDo
     WHERE lukaOd.nazLuka = 'Rijeka' AND lukaDo.nazLuka = 'New York'
     AND ukUkrcTezina > 200;

  c) Ispisati registarski broj i ime brodova u obliku "regBrBrod-imeBrod" koji prosle godine nijednom
     nisu isplovljavali iz svoje maticne luke (2b)

     SELECT CONCAT(regBrBrod, '-', imeBrod) FROM brod 
     WHERE NOT EXISTS (
       SELECT * FROM plovidba 
       WHERE 
       plovidba.regBrBrod = brod.regBrBrod
       plovidba.sifLukaOd = brod.sifMaticLuka AND 
       YEAR(datPolaska) = YEAR(curdate()) - 1 )





1.) 9.11.2017
VOZAC                                                               TERET
  sif_vozac   INT       (sifra vozaca)                                sif_teret   SMALLINT    (sifra tereta)
  prez_vozac  CHAR      (prezime vozaca)                              naz_teret   CHAR        (naziv tereta)
  ime_vozac   CHAR      (ime vozaca)                                  tezina      SMALLINT    (tezina tereta u tonama)

VOZNJA                                                              VOZILO 
  sif_voznja  INT       (sifra voznje)                                regbr       CHAR    (registarski broj vozila)
  sif_vozac   INT       (sifra vozaca)                                tip         CHAR    (tip vozila)
  sif_teret   SMALLINT  (sifra tereta)                                nosivost    DECIMAL (nosivost vozila u tonama)
  datum       DATE      (datum obavljanja prevoza)
  regbr       CHAR      (registarski broj vozila)                   LOKACIJA 
  broj_km     SMALLINT  (broj predjenih (prevezenih) kilometara)      sif_lok     INT     (sifra lokacije)
  sif_lok_od  INT       (sifra lokacije od koje se prevozi teret)     naz_lok     CHAR    (naziv lokacije)
  sif_lok_do  INT       (sifra lokacije do koje se prevozi teret)     adresa      CHAR    (adresa na kojoj se lokaciji nalazi)
                                                                      grad        CHAR    (grad u kojem se lokacija nalazi)

Napisati po jednu SQL naredbu za svaki sljedeci zadatak. Upiti moraju biti neovisni o datumu izvodjenja.

  a) Ispisati popis vozaca (ime i prezime) koji su u posljednjem tromjesecju prosle godine obavili bar jednu
     voznju u vozilima ciji tip sadrzi rijec "MERCEDES", a ne sadrzi cifru. Svaki takav vozac se u popisu
     treba naci samo jednom. (2b)


        SELECT DISTINCT ime_vozac, prez_vozac FROM vozac INNER JOIN voznja ON vozac.sif_vozac = voznja.sif_vozac
        INNER JOIN vozilo on vozilo.regbr = voznja.regbr
        WHERE MONTH(datum) IN (10,11,12) AND YEAR(datum) = YEAR(curdate()) - 1 
        AND tip LIKE '%MERCEDES%' AND tip NOT RLIKE '[0-9]';

  b) Ispisati broj voznji, ukupan broj predjenih kilometara i prosjecnu tezinu tereta obavljene vozilima 
     nosivosti izmedju 5 i 10t, a koje su krenule iz gradova ciji nazivi pocinju slovima od K do P i ne 
     zavrsavaju samoglasnikom. (2b)

       SELECT COUNT(sif_voznja), SUM(broj_km), AVG(tezina) FROM VOZNJA 
       INNER JOIN VOZILO ON VOZNJA.regbr = VOZILO.regbr INNER JOIN TERET ON VOZNJA.sif_teret = TERET.sif_teret
       INNER JOIN LOKACIJA ON lokacija.sif_lok = voznja.sif_lok_od WHERE 
       nosivost between 5 AND 10 AND lokacija.grad RLIKE '^[K-P]' AND grad NOT RLIKE '[aeiou]$';

  c) Ispisati ime i prezime vozaca, registarski broj i tip vozila za voznje koje su proslog mjeseca 
     obavljene izmedju lokacija koje se ne nalaze u istom gradu (2b)

       SELECT ime_vozac, prez_vozac, vozilo.regbr, tip FROM VOZAC INNER JOIN voznja 
       ON voznja.sif_vozac = vozac.sif_vozac INNER JOIN VOZILO on vozilo.regbr = voznja.regbr 
       INNER JOIN lokacija lokOd ON lokOd.sif_lok = voznja.sif_lok_od
       INNER JOIN lokacija lokDo ON lokDo.sif_lok = voznja.sif_lok_do 
       WHERE MONTH(datum) = MONTH(DATE_SUB(curdate(), interval 1 month))
       AND YEAR(datum) = YEAR(DATE_SUB(curdate(), Interval 1 month))
       AND lokOd.grad <> lokDo.grad;

1.) 16.11.2021
U bazi podataka PRIJAVE nalaze se relacije (primarni kljucevi relacija su oznaceni sa *)

STUD                                                VRSTA_PROVJ
* mbrStud  INT    (maticni broj studenta)           * sifProvj       INT   (sifra vrste provjere) 
  imeStud  CHAR   (ime studenta)                      nazivVrProvj   CHAR  (naziv vrste provjere, zavrsni ispit, medjuispit,..)
  prezStud CHAR   (prezime studenta)                
                                                    PROVJERA 
NASTAVNIK                                           * datProvjera    DATE  (datum odrzavanja provjere)
* sifNast   INT    (sifra nastavnika)               * sifPred        INT   (sifra predmeta iz kojeg se odrzava provjera) 
  imeNast   CHAR   (ime nastavnika)                   sifVrProvj     INT   (sifra vrste provjere koja se odrzava)
  prezNast  CHAR   (prezime nastavnika)               vrijemeProvj   TIME  (vrijeme pocetka provjere)
                                                      trajanje       INT   (trajanje provjere u minutama) 
PRED                                                  sifNast        INT   (sifra nastavnika koji obavlja provjeru) 
* sifPred   INT    (sifra predmeta)                       
  nazPred   CHAR   (naziv predmeta)                 PRIJAVA
                                                    * datProvjera    DATE  (datum odrzavanja provjere)
PREDAJE                                             * sifPred        INT   (sifra predmeta iz kojeg se odrzava provjera)
* sifPred   INT    (sifra predmeta)                 * mbrStud        INT   (maticni broj studenta koji obavlja prijavu)
* sifNast   INT    (sifra nstavnika)                  datPrijava     DATE  (datum kada je obavljena prijava)
  nosilac   BOOL   (da li je nosilac predmeta)        vrijemePrijave TIME  (vrijeme kada je obavljena prijava)


Napisati po jednu SQL naredbu za svaki sljedeci zadatak. Upiti moraju biti neovisni o datumu izvodenja.
Nece se priznavati rjesenja u kojima se nepotrebno koriste podupiti.

  a) Ispisati ukupan broj prijava koje su studenti obavili dva ili manje dana prije odrzavanja bilo kojeg 
     zavrsnog ispita iz predmeta ciji naziv pocinje nekim od slova izmedju O i T i u nazivu ne sadrze cifru. (2b)

     STELECT count(*) FROM PRIJAVA INNER JOIN PROVJERA ON PRIJAVA.datProvjera = PROVJERA.datProvjera 
     INNER JOIN VRSTA_PROVJ on VRSTA_PROVJ.sifProvj = PROVJERA.sifVrProvj 
     INNER JOIN PRED ON PRED.sifPred = PROVJERA.sifPred
     WHERE nazivVrProvj = 'Zavrsni ispit' AND nazPred RLIKE '^[OT]' AND nazPred NOT RLIKE '[0-9]'
     AND DATEDIFF(provjera.datProvjera, prijava.datPrijava) BETWEEN 1 AND 2;

  b) Za svaku provjeru koja ce se odrzati u bilo koju subotu u narednih 3 mjeseca (racunajuci od dana izvodjenja
     upita) ispisati naziv predmeta, datum provjere, vrijeme pocetka provjere, ime i prezime nastavnika koji 
     obavlja provjeru i ime i prezime nastavnika koji je nosilac na predmetu. (2b)

      SELECT nazPred, datProvjera, vrijemeProvjr, nastOb.imeNast, nastOb.prezNast, nastNos.imeNast, nastNos.prezNast 
      FROM PRED INNER JOIN PROVJERA on PRED.sifPred = Provjera.sifPred INNER JOIN nastavnik nastOb 
      ON nastOb.sifNast = PROVJERA.sifNast INNER JOIN nastavnik nastNos ON nastNos.sifNast = Provjera.sifNast 
      INNER JOIN PREDAJE ON PREDAJE.sifNast = nasNos.sifNast
      INNER JOIN PRIJAVA ON Prijava.datProvjera = Provjera.datProvjera
      WHERE PREADJE.nosilac = 1 AND WEEKDAY(datProvjera) = 5 AND datProvjere <= DATE_ADD(datPrijava, INTERVAL 3 MONTH);

  c) Ispisati naziv predmeta, datum odrzavanja i ime i prezime nastavnika koji obavlja provjeru za sve provjere 
     kojima je trajanje duze od prosjecnog trajanja svih provjera na predmetima kojima je taj nastavnik odgovorni
     nosilac. (2b)

      SELECT nazPred, datProvjera, imeNast, prezNast FROM PRED INNER JOIN PROVJERA ON pred.sifPred = provjera.sifPred
      INNER JOIN nstavnik ON nastavnik.sifPred = provjera.sifPred 
      WHERE trajanje >= (
        SELECT AVG(pr2.trajanje)
        FROM predaje pd 
        INNER JOIN PROVJERA pr2
          ON pr2.sifPred = pd.sifPred

      

1.) 7.12.2011
Medju ucenicima koji zavrsavaju srednju skolu i zele se upisati na fakultet provedena je anleta.
U bazi podataka nalaze se relacije:

MJESTO                                                                    UCENIK 
* pbr        INT      (postanski broj)                                    * jmbg        CHAR   (JMBG ucenika)
  nazMjesto  VARCHAR  (naziv mjesta)                                        prezUcenik  NCHAR  (prezime ucenika)
                                                                            imeUcenik   NCHAR  (ime ucenika)
SKOLA                                                                       sifSkola    INT    (sifra srednje skole koju ucenik pohadja)
* sifSkola   INT      (sifra skole)                                         sifFakultet INT    (sifra fakulteta na kojeg se ucenik zeli upisati)
  nazSkola   VARCHAR  (naziv skole)                                         opciUspjeh  SMINT  (opci uspjeh)
  pbrSkola   INT      (postanski broj mjesta u kojem se skola nalazi)

FAKULTET 
* sifFakultet     INT      (sifra fakulteta)
  nazFakultet     VARCHAR  (naziv fakulteta) 
  pbrFakultet     INT      (postanski broj mjesta u kojem se nalazi fak)
  adresaFakultet  VARCHAR  (adresa fakulteta)


Napisati po jednu SQL naredbu za svaki sljedeci zadatak:
  
  a) Ispisati ukupan broj i prosjecan opci uspjeh ucenika koji pohadjaju srednju skolu u mjestima 
     ciji naziv zapocinje slovima S do Z. (2b)

  b) Ispisati JMBG, ime i prezime ucenika, naziv mjesta srednje skole i mjesta fakulteta za ucenkike
     koji ne pohadjaju srednju skolu u istom mjestu u kojem se nalazi fakultet na kojeg se zele upisati.
     Ne koristiti podupite! (2b)

1.) 16.11.2012
U bazi podataka DRZAVLJANI nalaze se relacije 

DRZAVA                                                OSOBA
* oznDrzava   CHAR   (oznaka drzave)                  * sifOsoba   INT   (sifra osobe)
  nazDrzava   CHAR   (naziv drzave)                     imeOsoba   CHAR  (ime osobe)
                                                        prezOsoba  CHAR  (prezime osobe)
MJESTO                                                  oznDvorana CHAR  (oznaka drzave u kojoj je osoba rodjena)
* oznDrzava   CHAR   (oznaka drzave)                    pbr        CHAR  (postanski broj mjesta u kojem je osoba rodjena)
  pbr         CHAR   (postanski broj mjesta)            datRod     DATE  (datum rodjenja osobe, mora biti veci od datuma 12.10.1492)
  nazMjesto   CHAR   (naziv mjesta)                   
                                                      DRZAVLJANSTVO
                                                      * sifOsoba   INT   (sifra osobe)
                                                      * oznDrzava  CHAR  (oznaka drzave za koju je osoba stekla drzavljanstvo)
                                                        datDrz     DATE  (datum kojeg je osoba stekla drzavljanstvo)

Pretpostavlja se da jedna osoba drzavljanstvo jedne drzave moze imati samo jednom (to proizilazi iz kljuca
relacije drzavljanstvo). Pretpostavlja se da niti jedan podatak u bazi ne moze poprimiti NULL vrijednost.

Napisati po jednu SQL naredbu za svaki sljedeci zadatak:

  a) Ispisati popis osoba (sifru, prezime i ime) koje su bilo koje od svojih drzavljanstava drzava ciji naziv
     pocinje suglasnikom a zavrsava samoglasnik stekle na svoj dvadeseti rodjendan. Prepostavlja se da u 
     relaciji osoba ne postoji niti jedna osoba rodjena 29.februara (tak oda ne treba voditi racuna o tome
     postojil li dvadeseti rodjendan takvih osoba). Svaka se osoba u popisu smije pojaviti najvise jednom.
     Upotreba podupita nije dozvoljena. (2b)


  b) Ispisati popis osoba (sifru, prezime i ime) koje su rodjene u drzavi pod nazivom Jugoslavija i imaju 
     drzavljanstvo drzave pod nazivom USA (pri tome nije bitno imaju li drzavljanstvo neke druge drzave)
     Upotreba podupita nije dozvoljena. (2b)

  c) Ispisati popis osoba (prezime, ime, starost osobe izrazenu u danima i naziv mjesta rodjenja) koje imaju
     drzavljanstvo neke drzave koje nema niti jedna druga osoba. (2b)
      

1.) 9.11.2017

    U bazi podataka BIBLIOTEKA nalaze se relacije (primarni kljucevi su oznaceni) 

    KNJIGA      STUDENT      PREDMET
    *sifKnj     *JMBG        *sifPred
    naslov      ime          nazPred
    cijena      prezime

    LITERATURA 
    *sifPred
    *sifKnj 
    rbr             redni broj vaznosti literature za predmet (za svaki predmet krece od 1)
    obavezna        D-obavezna literatura, N-neobavezna literatura

    POSUDBA 
    *JMBG
    *sifKnj         
    datumPos       rok vracanja knjige (datum do kojeg studenta mora vratiti knjgu)
    datumVra       datum vracanja knjige


    Napisati po jedan SQL upit za svaki od zadatka.
    Upiti moraju biti neovisni o datumu izvodjenja.

    a) Za svaki predmet ciji naziv sadrzi rijec "osnovi" i zavrsava samoglasnikom 
    ispisati obaveznu literaturu.
    Potrebno je ispisati naziv predmeta, naziv knjige te oznaku (niz znakova) 
    sastavljenu od prva tri znaka naslova knjige i sifre predmeta (npr. ako je za
    predmet sa sifrom 1000 obavezna knjiga 'Baze podataka' ispisat ce se 
    'Baz1000') (2b)

    b) Ispisati ukupnu i prosjecnu vrijednost svih knjiga koje su posudjene u 
    proslom mjesecu, a nisu vracene na vrijeme.
    Kao naslov za izracunatu ukupnu i prosjecnu vrijednost u izlaznoj se listi
    pojavljuje tekst "ukupno" i "prosjek" (2b)

    c) Ispisati sve podatke o studentima koji su prosudili knjigu koju je taj dan
    vratio neki drugi student (2b)

